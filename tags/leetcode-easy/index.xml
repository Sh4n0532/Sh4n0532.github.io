<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode (Easy) on Sh4n&#39;s Portfolio and Blog</title>
    <link>https://sh4n0532.github.io/tags/leetcode-easy/</link>
    <description>Recent content in LeetCode (Easy) on Sh4n&#39;s Portfolio and Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 27 Dec 2020 16:40:45 +0800</lastBuildDate><atom:link href="https://sh4n0532.github.io/tags/leetcode-easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Marge Two Sorted Lists</title>
      <link>https://sh4n0532.github.io/posts/merge-two-sorted-lists/</link>
      <pubDate>Sun, 27 Dec 2020 16:40:45 +0800</pubDate>
      
      <guid>https://sh4n0532.github.io/posts/merge-two-sorted-lists/</guid>
      <description>Problem Description Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.
Example 1:
Solution /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.</description>
    </item>
    
    <item>
      <title>Valid Parentheses</title>
      <link>https://sh4n0532.github.io/posts/valid-parentheses/</link>
      <pubDate>Sun, 20 Dec 2020 18:13:37 +0800</pubDate>
      
      <guid>https://sh4n0532.github.io/posts/valid-parentheses/</guid>
      <description>Problem Description Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
An input string is valid if:
 Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Example 4:
Input: s = &amp;#34;([)]&amp;#34; - the order must also be correct Output: false Solution class Solution { public boolean isValid(String s) { HashMap&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); map.</description>
    </item>
    
    <item>
      <title>Longest Common Prefix</title>
      <link>https://sh4n0532.github.io/posts/longest-common-prefix/</link>
      <pubDate>Sun, 13 Dec 2020 18:48:29 +0800</pubDate>
      
      <guid>https://sh4n0532.github.io/posts/longest-common-prefix/</guid>
      <description>Problem Description Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;quot;&amp;quot;.
Example 1:
Input: strs = [&amp;#34;flower&amp;#34;,&amp;#34;flow&amp;#34;,&amp;#34;flight&amp;#34;] Output: &amp;#34;fl&amp;#34; Example 2:
Input: strs = [&amp;#34;racecar&amp;#34;,&amp;#34;car&amp;#34;] Output: &amp;#34;&amp;#34; Explanation: There is no common prefix among the input strings. Solution class Solution { public String longestCommonPrefix(String[] strs) { String prefix = &amp;#34;&amp;#34;; if (strs == null || strs.</description>
    </item>
    
    <item>
      <title>Roman to Integer</title>
      <link>https://sh4n0532.github.io/posts/roman-to-integer/</link>
      <pubDate>Sun, 29 Nov 2020 17:56:10 +0800</pubDate>
      
      <guid>https://sh4n0532.github.io/posts/roman-to-integer/</guid>
      <description>Problem Description Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description>
    </item>
    
    <item>
      <title>Palindrome Number</title>
      <link>https://sh4n0532.github.io/posts/palindrome-number/</link>
      <pubDate>Sun, 22 Nov 2020 00:18:17 +0800</pubDate>
      
      <guid>https://sh4n0532.github.io/posts/palindrome-number/</guid>
      <description>Problem Description Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Constraint: Must within the range of Integer.
Follow up: Could you solve it without converting the integer to a string?
Example 1:
Input: x = 121 Output: true Example 2:
Input: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-.</description>
    </item>
    
    <item>
      <title>Reverse Number</title>
      <link>https://sh4n0532.github.io/posts/reverse-number/</link>
      <pubDate>Sun, 22 Nov 2020 00:12:08 +0800</pubDate>
      
      <guid>https://sh4n0532.github.io/posts/reverse-number/</guid>
      <description>Problem Description Given a 32-bit signed integer, reverse digits of an integer.
Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
Input: x = 123 Output: 321 Solutions class Solution { public int reverse(int x) { long rev = 0; while (x !</description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>https://sh4n0532.github.io/posts/two-sum/</link>
      <pubDate>Sun, 15 Nov 2020 00:06:33 +0800</pubDate>
      
      <guid>https://sh4n0532.github.io/posts/two-sum/</guid>
      <description>Problem Description Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
  </channel>
</rss>
